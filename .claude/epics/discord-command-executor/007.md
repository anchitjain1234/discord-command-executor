---
name: Real-time Output Streaming
status: open
created: 2025-08-20T18:10:29Z
updated: 2025-08-20T18:10:29Z
last_sync: 2025-08-20T19:57:01Z
github: https://github.com/anchitjain1234/discord-command-executor/issues/4
depends_on: [003]
parallel: true
conflicts_with: [008]
---

# Task: Real-time Output Streaming

## Description

Implement real-time output streaming for long-running commands that provides live updates to Discord messages as command output is generated. This system should use a rolling buffer approach to handle continuous output streams while respecting Discord's message length limits and API rate limiting constraints.

The streaming system will capture stdout/stderr from executing commands and progressively update Discord messages, providing users with immediate feedback for commands that produce output over time (builds, tests, monitoring commands, etc.).

## Acceptance Criteria

### Core Functionality
- [ ] Real-time capture and streaming of command stdout/stderr to Discord
- [ ] Progressive message updates showing command output as it's generated
- [ ] Rolling buffer management with configurable size limits (default: 10MB)
- [ ] Intelligent truncation that preserves recent output and command context
- [ ] Support for concurrent streaming from multiple simultaneous commands
- [ ] Graceful handling of Discord API rate limits with backoff strategies

### Performance Requirements
- [ ] Output streaming latency <100ms from command generation to Discord update
- [ ] Efficient memory usage with circular buffer implementation
- [ ] Support for high-throughput commands (>1MB/sec output) without blocking
- [ ] CPU usage <5% for streaming operations under normal load

### User Experience
- [ ] Clear indicators for live/completed command status
- [ ] Preserved command context (command line, start time) in all updates
- [ ] Smooth message updates without jarring content jumps
- [ ] Final message shows complete command summary (exit code, duration, final output)

### Error Handling
- [ ] Robust handling of Discord API failures with retry logic
- [ ] Graceful fallback when message update limits are reached
- [ ] Recovery from network interruptions during streaming
- [ ] Clear error messages for streaming failures

## Technical Details

### Architecture Components

**Streaming Engine (`output/streamer.go`)**
```go
type OutputStreamer struct {
    buffer     *RollingBuffer
    discord    *discord.Client
    rateLimiter *RateLimiter
    config     *StreamConfig
}

type StreamConfig struct {
    BufferSize       int64         // 10MB default
    UpdateInterval   time.Duration // 1s default
    MaxUpdateSize    int           // 1900 chars for Discord
    TruncationPrefix string        // "...[truncated]..."
}
```

**Rolling Buffer Implementation (`output/buffer.go`)**
```go
type RollingBuffer struct {
    data        []byte
    size        int64
    maxSize     int64
    writePos    int64
    full        bool
    mu          sync.RWMutex
}
```

**Discord Integration (`discord/streaming.go`)**
```go
type MessageStreamer struct {
    session     *discordgo.Session
    channelID   string
    messageID   string
    lastContent string
    updateQueue chan StreamUpdate
}
```

### Implementation Strategy

**1. Output Capture**
- Use `os/exec.StdoutPipe()` and `os/exec.StderrPipe()` for real-time capture
- Implement goroutine-based output readers with channel communication
- Merge stdout/stderr streams with timestamp prefixes
- Handle partial line reads and buffer management

**2. Rolling Buffer Management**
- Circular buffer implementation for memory efficiency
- Configurable size limits with automatic truncation
- Thread-safe operations for concurrent read/write
- Intelligent truncation preserving command start and recent output

**3. Discord Message Updates**
- Rate-limited message editing using Discord API
- Batched updates to minimize API calls while maintaining responsiveness  
- Content diffing to avoid unnecessary updates
- Fallback to new messages when edit limits exceeded

**4. Concurrency Handling**
- Separate goroutines for each streaming command
- Channel-based communication between components
- Context cancellation for cleanup on command completion
- Resource pooling for concurrent stream management

### Data Flow
```
Command Execution → Output Pipes → Rolling Buffer → Discord Updater → Discord API
                                                  ↗
                               Rate Limiter ──┘
```

## Dependencies

### Internal Dependencies
- **Task 003**: Basic command execution infrastructure must be complete
- `executor/command.go`: Command execution with output pipe access
- `discord/bot.go`: Discord client integration
- `config/config.go`: Streaming configuration management

### External Dependencies
- `discordgo` library for Discord API message operations
- `time` package for rate limiting and intervals
- `sync` package for concurrent buffer access
- `context` package for cancellation handling

## Effort Estimate

**Total: 3 days**

**Day 1: Core Infrastructure (8 hours)**
- Implement `RollingBuffer` with circular buffer logic
- Create `OutputStreamer` structure and interfaces
- Build basic output capture from command pipes
- Write comprehensive unit tests for buffer operations

**Day 2: Discord Integration (8 hours)**
- Implement `MessageStreamer` for Discord message updates
- Add rate limiting and backoff strategies
- Integrate with existing Discord bot framework
- Build content diffing and update optimization

**Day 3: Integration & Testing (8 hours)**
- Connect streaming engine to command execution system
- Add configuration management for streaming parameters
- Write integration tests with mock Discord API
- Performance testing with high-throughput commands
- Error handling and edge case testing

## Definition of Done

### Code Quality
- [ ] All code follows project Go style guidelines
- [ ] Unit test coverage >90% for streaming components
- [ ] Integration tests covering Discord API interaction
- [ ] Performance tests validating latency and throughput requirements
- [ ] Race condition testing with concurrent streams

### Functionality
- [ ] Real-time output streaming functional for all command types
- [ ] Rolling buffer correctly manages memory with large outputs
- [ ] Discord message updates work reliably with rate limiting
- [ ] Multiple concurrent commands can stream simultaneously
- [ ] Streaming gracefully handles command completion and errors

### Performance
- [ ] Streaming latency benchmarked at <100ms
- [ ] Memory usage remains constant regardless of command output size
- [ ] CPU overhead <5% during active streaming
- [ ] Support for 10+ concurrent streaming commands

### Integration
- [ ] Seamless integration with existing command execution system
- [ ] Configuration options properly loaded from YAML config
- [ ] Audit logging captures streaming events and errors
- [ ] Clean shutdown and resource cleanup on bot termination

**Ready for Production**: Real-time output streaming works reliably for long-running commands with efficient resource usage and robust error handling.